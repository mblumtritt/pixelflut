#!/usr/bin/env ruby
# frozen_string_literal: true

def options(cfg)
  require 'optparse'
  OptionParser.new do |opts|
    opts.summary_indent = '  '
    opts.banner = 'usage: pxf info [options]'
    opts.separator(nil)
    opts.separator('valid options:')
    opts.on('-h', '--host HOST', String, 'target host name (default localhost)'){ |v| cfg[:host] = v }
    opts.on('-p', '--port PORT', Integer, 'target port (default 1234)'){ |v| cfg[:port] = v }
  end
end

def help(short)
  puts(options(nil), nil) unless short
  puts('Get info about a Pixelflut server.')
  exit
end

def err(msg, code = 1)
  $stderr.puts("pxf: #{msg}")
  exit(code)
end

def create_options
  {port: 1234}.tap{ |cfg| options(cfg).parse! }
rescue OptionParser::ParseError => e
  err(e)
end

help(false) if '--help' == ARGV[0]
help(true) if '--short-help' == ARGV[0]
options = create_options
require File.realdirpath('../../lib/pixelflut/client/socket.rb', __FILE__)
begin
  socket = Pixelflut::Client::Socket.new(Addrinfo.tcp(options[:host], options[:port]))


  err("unable to connect - #{options[:host]}:options[:port])", 2) unless socket.connect? || socket.wait_writable(5)
  err("server busy - #{options[:host]}:options[:port])", 3) unless socket.write_with_timout("SIZE\n", 5)
  line = socket.readline_with_timeout(5)
  socket.close
  err("server does not respond - #{options[:host]}:options[:port])", 4) unless line
  mark, width, height = line.split(' ', 3)
  width = width.to_i
  height = height.to_i
  err("no Pixelflut server - #{options[:host]}:options[:port])", 5) if mark != 'SIZE' || width <= 0 || height <= 0
  puts "canvas size: #{width}x#{height}"
rescue SocketError, SystemCallError => e
  err(e.message, 2)
rescue Interrupt
  exit
end
