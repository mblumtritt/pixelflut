#!/usr/bin/env ruby
# frozen_string_literal: true

Process.setproctitle($name = 'pxf')
$stderr.sync = $stdout.sync = true

require 'optparse'
require_relative '../lib/pixelflut'

def err(msg, code = 1)
  $stderr.puts("#{$name}: #{msg}")
  exit(code)
end

OPTS = Struct
  .new(:host, :port, :count, :x, :y, :mode, :scale, :image)
  .new('127.0.0.1', 1234, 4, 0, 0, :rgbx)

def parse(args)
  OptionParser.new do |parser|
    parser.summary_indent = '  '
    parser.banner = 'Usage: pxf [options] IMAGE'
    parser.separator(nil)
    parser.separator('Options:')
    parser.on(
      '--host ADDRESS', 'target host address'
    ){ |v| OPTS.host = v }
    parser.on(
      '-p', '--port NUMBER', Integer, 'target port (default 1234)'
    ){ |v| OPTS.port = v }
    parser.on(
      '-c', '--connections COUNT', Integer, 'count of connections (default 4)'
    ){ |v| OPTS.count = v }
    parser.on(
      '-x', '--transpose-x X', Integer, 'transpose image X pixels'
    ){ |v| OPTS.x = v }
    parser.on(
      '-y', '--transpose-y Y', Integer, 'transpose image Y pixels'
    ){ |v| OPTS.y = v }
    parser.on(
      '-s', '--scale FACTOR', OptionParser::DecimalNumeric, 'scale image by FACTOR'
    ){ |v| OPTS.scale = v }
    parser.on(
      '-m', '--pixel MODE',
      {'RGBX' => :rgbx, 'RGBA' => :rgba, 'RGB' => :rgb},
      'select pixel coding (RGBX | RGBA | RGB)'
    ){ |v| OPTS.mode = v }
    parser.separator(nil)
    parser.on('-h', '--help', 'print this help') do
      exit(!puts(parser))
    end
    parser.on('-v', '--version', 'print version information') do
      require_relative '../lib/pixelflut/version'
      exit(!puts("pxf-#{Pixelflut::VERSION}"))
    end
  end.parse!(args)
  OPTS.image = args.first or err('image name expected')
  OPTS
rescue OptionParser::ParseError => e
  err(e)
end

begin
  parse(ARGV)
  addr = Pixelflut::Sender.address(OPTS.host, OPTS.port)
  slices = Pixelflut.as_slices(
    source: OPTS.image,
    count: OPTS.count,
    x: OPTS.x,
    y: OPTS.y,
    scale: OPTS.scale,
    mode: OPTS.mode
  )
  slices.size.times do |i|
    next unless fork
    Process.setproctitle($name = format('pxf-%02d', i + 1))
    sender = Pixelflut::Sender.new(addr, slices[i].join)
    slices.clear
    puts("#{$name}: run - #{sender.size} bytes")
    sender.run{ puts("#{$name}: sent partly") }
  end
rescue SocketError => e
  err(e, 3)
rescue LoadError => e
  err(e, 4)
rescue Errno::EPIPE
  err('connection lost', 2)
rescue Interrupt
  err('interrupted', 130)
end
