#!/usr/bin/env ruby
# frozen_string_literal: true

$stdout.sync = $stderr.sync = true
Process.setproctitle($name = 'pxf')

if ARGV.index('-h') || ARGV.index('--help')
  puts <<~HELP
    Usage: #{$name} <image> [options]

    Options:
          --host <address>       target host address
      -p, --port <port>          target port (default 1234)
      -c, --connections <count>  count of connections (default 4)
      -x, --transpose-x <x>      transpose image <x> pixels
      -y, --transpose-y <y>      transpose image <y> pixels
      -s, --scale <scale>        scale image by factor
      -m, --pixel <mode>         select pixel coding (RGBX | RGBA | RGB)
      -h, --help                 print this help
      -v, --version              print version
  HELP
  exit
end

if ARGV.index('-v') || ARGV.index('--version')
  require_relative('../lib/pixelflut/version')
  puts("#{$name} v#{Pixelflut::VERSION}")
  exit
end

def die!(msg, code: 1)
  $stderr.puts("#{$name}: #{msg}")
  exit(code)
end

die!('argument missing') if ARGV.empty?

module Configuration
  class << self
    def parse(argv)
      argv = Array.new(argv)
      until argv.empty?
        case arg = argv.shift
        when '--host'
          @address = as_str(argv.shift, 'host')
        when '-p', '--port'
          @port = as_uint(argv.shift, 'port')
        when '-c', '--connections'
          @num_connections = as_uint(argv.shift, 'connections')
        when '-x', '--transpose-x'
          @trans_x = argv.shift.to_i
        when '-y', '--transpose-y'
          @trans_y = argv.shift.to_i
        when '-s', '--scale'
          @scale = as_float(argv.shift, 'scale')
        when '-m', '--pixel'
          @mode = as_mode(argv.shift, 'mode')
        else
          die!("invalid option - #{arg}") if @image
          @image = arg
        end
      end
      die!('<image> missing') if @image.nil?
      self
    end

    def options
      {
        source: @image,
        x: @trans_x || 0,
        y: @trans_y || 0,
        scale: @scale,
        mode: @mode || 'rgbx',
        slices: @num_connections || 4
      }
    end

    def address
      Pixelflut::Sender.as_address(@address || '127.0.0.1', @port || 1234)
    end

    private

    def invalid(value, name)
      die!("value for #{name} missing") if value.nil?
      die!("invalid value for #{name} - '#{value}'")
    end

    def as_str(value, name)
      value.nil? || value.empty? ? invalid(value, name) : value
    end

    def as_uint(value, name)
      ret = value.to_i
      ret.positive? ? ret : invalid(value, name)
    end

    def as_float(value, name)
      ret = value.to_f
      ret.positive? ? ret : invalid(value, name)
    end

    def as_mode(value, name)
      v = value.downcase
      return v if %w[rgbx rgba rgb].include?(v)
      invalid(value, name)
    end
  end

  parse(ARGV)
end

begin
  require_relative('../lib/pixelflut/sender')
  address = Configuration.address
  require_relative('../lib/pixelflut')
  data = Pixelflut.slices(**Configuration.options)
  count = data.size
  die!("too many subprocesses - #{count}") if count > 256
  puts("#{$name} spawn #{count} processes:")
  count.times do |i|
    next unless fork
    Process.setproctitle($name = format("%s-%02d", $name, i + 1))
    data = data[i]
    Pixelflut::Sender.send(address, data) do |size|
      GC.start
      GC.disable
      puts("#{$name}: #{size} bytes")
    end
  end
rescue Errno::ECONNREFUSED
  die!('unable to connect', code: 2)
rescue Errno::EPIPE
  die!('connection lost', code: 2)
rescue SocketError => e
  die!(e, code: 3)
rescue LoadError => e
  die!(e, code: 4)
rescue Interrupt
  puts("\b\b  ") if $stdout.tty?
  die!('aborted', code: 130)
end
